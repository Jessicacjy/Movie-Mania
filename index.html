<!DOCTYPE html>
<meta charset="utf-8">
<style>

#search {
    background-image: url('/css/searchicon.png'); /* Add a search icon to input */
    background-position: 10px 12px; /* Position the search icon */
    background-repeat: no-repeat; /* Do not repeat the icon image */
    width: 20%;
    font-size: 16px; /* Increase font-size */
    padding: 12px 20px 12px 40px; /* Add some padding */
    border: 1px solid #ddd; /* Add a grey border */
    margin-bottom: 12px; /* Add some space below the input */
}    
    
.links line {
    stroke: #999;
    stroke-opacity: 0.6;
}
    
.links .unfocus_links {
    stroke-opacity: 0.1;
}

.nodes circle {
    stroke: #fff;
    stroke-width: 1.5px;
    opacity: 1;
}

.nodes .highlight_node {
    stroke: #000;
}    
    
.nodes .unfocus_nodes {
    opacity: 0.1;
}

</style>
<input type="text" id="search" onkeyup="myFunction()" placeholder="Search for names..">
<svg width="1920" height="1080"></svg>
<script src="https://d3js.org/d3.v4.min.js"></script>
<script>

var input, filter;
    
var svg = d3.select("svg"),
    width = +svg.attr("width"),
    height = +svg.attr("height");

var simulation = d3.forceSimulation()
    .force("link", d3.forceLink().id(function(d) { return d.id; }))
    .force("charge", d3.forceManyBody())
    .force("center", d3.forceCenter(width / 2, height / 2));

var focus_node = null;

var node_color = d3.scaleOrdinal(d3.schemeCategory10);    

var link_width = d3.scaleSqrt()
    .range([1,8])

var node_radius = d3.scaleSqrt()
    .range([5,15]);

d3.json("network.json", function(error, rawGraph) {
    if (error) throw error;

    link_width.domain(d3.extent(rawGraph.links, function(d) { return d.strength; }));
    node_radius.domain(d3.extent(rawGraph.nodes, function(d) { return d.movie_count; }));
    
    filter = "clint eastwood";
    console.log(rawGraph);
    graph = filterGraph(rawGraph, filter);
//    graph = rawGraph;
    console.log(graph)
    
    var linkedByIndex = {};
    graph.links.forEach(function(d) { linkedByIndex[d.source + "," + d.target] = true; });

    var link = svg.append("g")
    .attr("class", "links")
    .selectAll("line")
    .data(graph.links)
    .enter().append("line")
    .attr("stroke-width", function(d) { return link_width(d.strength); });

    var node = svg.append("g")
    .attr("class", "nodes")
    .selectAll("circle")
    .data(graph.nodes)
    .enter().append("circle")
    .attr("r", function(d) { return node_radius(d.movie_count); })
    .attr("fill", function(d) { return node_color(d.type); })
    .call(d3.drag()
          .on("start", dragstarted)
          .on("drag", dragged)
          .on("end", dragended));

    node.append("title")
      .text(function(d) { return d.id; });

    node.on("mouseover", set_highlight)
      .on("click", set_focus)
      .on("mouseout", exit_highlight);

    runSimulation();
  
    /* Filter the graph */
    function filterGraph(graph, filter) {
        var result = {};
        var filteredNodes = [];
        var filteredLinks = [];
        var collectIDs = [];
        
        // Filter the links
        for (var j in graph.links) {
            if (graph.links[j].source.toLowerCase() === filter || graph.links[j].target.toLowerCase() === filter) {
                filteredLinks = filteredLinks.concat(graph.links[j]);
                if (graph.links[j].source.toLowerCase() === filter) { collectIDs = collectIDs.concat(graph.links[j].target) }
                else { collectIDs = collectIDs.concat(graph.links[j].source) }
            }
        }
        
        // Filter the nodes
        for (var i in graph.nodes) {
            if (collectIDs.indexOf(graph.nodes[i].id) > -1 || filter === graph.nodes[i].id.toLowerCase()) {
                filteredNodes = filteredNodes.concat(graph.nodes[i]);
            }
        }
        
        result["nodes"] = filteredNodes;
        result["links"] = filteredLinks;
        return result;
    }
    
    /* Function to keep track of connections between nodes, used for focus/unfocus */
    function isConnected(a, b) {
        return linkedByIndex[a.id + "," + b.id] || linkedByIndex[b.id + "," + a.id] || a.id == b.id;
    }

    function hasConnections(a) {
        for (var property in linkedByIndex) {
            s = property.split(",");
            if ((s[0] == a.id || s[1] == a.id) && linkedByIndex[property])      return true;
        }
        return false;
    }
    
    /* Highlight only 1st degree neighbors on hover/selection */
    function set_highlight(d) {
        svg.style("cursor", "pointer");
        if (focus_node !== null)     d = focus_node;
//        highlight_node = d;
        node.classed("unfocus_nodes", function(o) { return isConnected(d, o) ? false : true; });
        link.classed("unfocus_links", function(o) { return o.source.id == d.id || o.target.id == d.id ? false : true; });
    }
    
    /* Sustain selection on click */
    function set_focus(d) {
        if (focus_node !== null) {
            node.classed('highlight_node', false);
            focus_node = null;
        }
        else {
            focus_node = d;
            node.classed('highlight_node', function(o) { return o.id == d.id ? true : false; });
            set_highlight(focus_node);
        }
    }

    /* Clear highlight on mouse out event */
    function exit_highlight() {
        svg.style("cursor", "auto");
//        highlight_node = null;
        if (focus_node === null) {
            node.classed("unfocus_nodes", false);
            link.classed("unfocus_links", false);
        }
    }
    
    function runSimulation() {
//        input = document.getElementById('search');
//        filter = input.value.toUpperCase();
        
        simulation
            .nodes(graph.nodes)
            .on("tick", ticked);

        simulation.force("link")
            .links(graph.links);
    }
    
    /* Update coordinates of nodes and links after each simulation iteration */
    function ticked() {
        link
            .attr("x1", function(d) { return d.source.x; })
            .attr("y1", function(d) { return d.source.y; })
            .attr("x2", function(d) { return d.target.x; })
            .attr("y2", function(d) { return d.target.y; });

        node
            .attr("cx", function(d) { return d.x; })
            .attr("cy", function(d) { return d.y; });
    }

    /* Functions to allow nodes to be dragged */
    function dragstarted(d) {
      if (!d3.event.active) simulation.alphaTarget(0.3).restart();
      d.fx = d.x;
      d.fy = d.y;
    }

    function dragged(d) {
      d.fx = d3.event.x;
      d.fy = d3.event.y;
    }

    function dragended(d) {
      if (!d3.event.active) simulation.alphaTarget(0);
      d.fx = null;
      d.fy = null;
    }

});

</script>