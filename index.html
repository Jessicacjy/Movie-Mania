<!DOCTYPE html>
<meta charset="utf-8">
<style>

/*
.dropbtn {
    background-color: #4CAF50;
    color: white;
    padding: 16px;
    font-size: 16px;
    border: none;
    cursor: pointer;
}

.dropbtn:hover, .dropbtn:focus {
    background-color: #3e8e41;
}
    
#myInput {
    border-box: box-sizing;
    background-image: url('searchicon.png');
    background-position: 14px 12px;
    background-repeat: no-repeat;
    font-size: 16px;
    padding: 14px 20px 12px 45px;
    border: none;
}

.dropdown {
    position: relative;
    display: inline-block;
}

.dropdown-content {
    display: none;
    position: absolute;
    background-color: #f6f6f6;
    min-width: 230px;
    overflow: auto;
    box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);
    z-index: 1;
}

.dropdown-content a {
    color: black;
    padding: 12px 16px;
    text-decoration: none;
    display: block;
}

.dropdown a:hover {background-color: #ddd}

.show {display:block;}
*/
    
.links line {
    stroke: #999;
    stroke-opacity: 0.5;
}
    
.links .highlight_link {
    stroke-opacity: 1;
}
    
.links .unfocus_links {
    stroke-opacity: 0.1;
}

.nodes circle {
    stroke: #fff;
    stroke-width: 1.5px;
    opacity: 1;
}

.nodes .highlight_node {
    stroke: #000;
}    
    
.nodes .unfocus_nodes {
    opacity: 0.1;
}

.d3-tip {
  line-height: 1;
  font-weight: bold;
  padding: 12px;
  background: rgba(0, 0, 0, 0.8);
  color: #fff;
  border-radius: 2px;
}

</style>

<!--
<div class="dropdown">
<button onclick="selectFilter()" class="dropbtn">Filter</button>
  <div id="filterDropdown" class="dropdown-content">
    <input type="text" placeholder="Search.." id="myInput" onkeyup="filterFunction()">
    <a href="#CE">Clint Eastwood</a>
    <a href="#MF">Morgan Freeman</a>
    <a href="#BP">Brad Pitt</a>
    <a href="#BDP">Brian De Palma</a>
    <a href="#CC">Chris Columbus</a>
    <a href="#DF">David Fincher</a>
    <a href="#SJ">Scarlett Johansson</a>
  </div>
</div>
-->

<div></div>
<svg width="1800" height="1800"></svg>
<script src="https://d3js.org/d3.v4.min.js"></script>
<script>

var input, filter;
var node, link;
var linkedByIndex = {};
var focus_node = null;

// Set appropriate scales
var node_color = d3.scaleOrdinal(["#b1e858", "#710394"])
                .domain(["Actor", "Director"]);
var node_radius = d3.scaleSqrt()
                .range([10, 20]);
var link_width = d3.scaleSqrt()
                .range([1, 8]);
var link_distance = d3.scaleSqrt()
                    .range([80, 30]);
var charge_strength = d3.scaleSqrt()
                        .range([-50, -2000]);

// Create dispatcher to link dropdown and graph events
var dispatch = d3.dispatch("load", "statechange");

// The dropdown menu element
var dropdown = d3.select("div");

// The SVG canvas
var svg = d3.select("svg"),
    width = +svg.attr("width"),
    height = +svg.attr("height");

// Setup the force-directed graph simulation
var simulation = d3.forceSimulation()
    .velocityDecay(0.8)
    .force("link", d3.forceLink().id(function(d) { return d.id; }).distance(function(d) { return link_distance(d.strength); }))
    .force("center", d3.forceCenter((width/2) - 125, (height/2) - 150))
    .force("collision", d3.forceCollide(function(d) { return node_radius(d.movie_count); }))
    .force("charge", d3.forceManyBody().distanceMax(200).strength(function(d) { return charge_strength(d.movie_count); }));
    
/* Load the JSON and initialize the elements through the dispatcher */
d3.json("network.json", function(error, rawGraph) {
    if (error) throw error;

    node_radius.domain(d3.extent(rawGraph.nodes, function(d) { return d.movie_count; }));
    link_width.domain(d3.extent(rawGraph.links, function(d) { return d.strength; }));
    link_distance.domain(d3.extent(rawGraph.links, function(d) { return d.strength; }));
    charge_strength.domain(d3.extent(rawGraph.nodes, function(d) { return d.movie_count; }));
    
    dispatch.call("load", this, rawGraph);
    dispatch.call("statechange", this, null);
    
//    input = document.getElementById('search');
//    filter = input.value.toUpperCase();
//    filter = "clint eastwood";
//    console.log(rawGraph);
//    filteredGraph = (filter === "") ? rawGraph : filterGraph(rawGraph, filter);
//    filteredGraph = rawGraph;
//    console.log(graph)
    
//    buildNetwork(rawGraph);
    
    /* Filter the graph */
//    function filterGraph(graph, filter) {
//        var result = {};
//        var filteredNodes = [];
//        var filteredLinks = [];
//        var collectIDs = [];
//        
//        // Filter the links
//        for (var j in graph.links) {
//            if (graph.links[j].source.toLowerCase() === filter || graph.links[j].target.toLowerCase() === filter) {
//                filteredLinks = filteredLinks.concat(graph.links[j]);
//                if (graph.links[j].source.toLowerCase() === filter) { collectIDs = collectIDs.concat(graph.links[j].target) }
//                else { collectIDs = collectIDs.concat(graph.links[j].source) }
//            }
//        }
//        
//        // Filter the nodes
//        for (var i in graph.nodes) {
//            if (collectIDs.indexOf(graph.nodes[i].id) > -1 || filter === graph.nodes[i].id.toLowerCase()) {
//                filteredNodes = filteredNodes.concat(graph.nodes[i]);
//            }
//        }
//        
//        result["nodes"] = filteredNodes;
//        result["links"] = filteredLinks;
//        return result;
//    }
    
});

/* Function to keep track of connections between nodes, used for focus/unfocus */
function isConnected(a, b) {
    return linkedByIndex[a.id + "," + b.id] || linkedByIndex[b.id + "," + a.id] || a.id == b.id;
}

function hasConnections(a) {
    for (var property in linkedByIndex) {
        s = property.split(",");
        if ((s[0] == a.id || s[1] == a.id) && linkedByIndex[property])      return true;
    }
    return false;
}    

/* Create a network graph */
function buildNetwork(graph) {
    graph.links.forEach(function(d) { linkedByIndex[d.source + "," + d.target] = true; });

    link = svg.append("g")
            .attr("class", "links")
            .selectAll("line")
            .data(graph.links)
            .enter().append("line")
            .attr("stroke-width", function(d) { return link_width(d.strength); });

    node = svg.append("g")
            .attr("class", "nodes")
            .selectAll("circle")
            .data(graph.nodes)
            .enter().append("circle")
            .attr("r", function(d) { return node_radius(d.movie_count); })
            .attr("fill", function(d) { return node_color(d.type); })
            .on("mouseover", function(d) {		
                div.transition()		
                    .duration(200)		
                    .style("opacity", .9);		
                div	.html(formatTime(d.date) + "<br/>"  + d.close)	
                    .style("left", (d3.event.pageX) + "px")		
                    .style("top", (d3.event.pageY - 28) + "px");	
                })					
            .on("mouseout", function(d) {		
                div.transition()		
                    .duration(500)		
                    .style("opacity", 0);	
                })
            .call(d3.drag()
                  .on("start", dragstarted)
                  .on("drag", dragged)
                  .on("end", dragended));

    /* Initialize tooltip */
//    tip = d3.tip().attr('class', 'd3-tip').html(function(d) { return d; });
//    
//    svg.call(tip);

    node.append("title")
      .text(function(d) { return d.id; });

    node.on("mouseover", set_highlight)
      .on("click", set_focus)
      .on("mouseout", exit_highlight);

    simulation
        .nodes(graph.nodes)
        .on("tick", ticked);

    simulation.force("link")
        .links(graph.links);
}
    
/* Highlight only 1st degree neighbors on hover/selection */
function set_highlight(d) {
    svg.style("cursor", "pointer");
    if (focus_node !== null)     d = focus_node;
    node.classed("unfocus_nodes", function(o) { return isConnected(d, o) ? false : true; });
    link.classed("unfocus_links", function(o) { return o.source.id == d.id || o.target.id == d.id ? false : true; });
}

/* Sustain selection on click */
function set_focus(d) {
    if (focus_node !== null) {
        node.classed('highlight_node', false);
        link.classed('highlight_link', false);
        focus_node = null;
    }
    else {
        focus_node = d;
        node.classed('highlight_node', function(o) { return o.id == d.id ? true : false; });
        link.classed('highlight_link', function(o) { return o.source.id == d.id || o.target.id == d.id ? true : false; });
        set_highlight(focus_node);
    }
}

/* Clear highlight on mouse out event */
function exit_highlight() {
    svg.style("cursor", "auto");
    if (focus_node === null) {
        node.classed("unfocus_nodes", false);
        link.classed("unfocus_links", false);
    }
}
    
/* Update coordinates of nodes and links after each simulation iteration */
function ticked() {
    link
        .attr("x1", function(d) { return d.source.x; })
        .attr("y1", function(d) { return d.source.y; })
        .attr("x2", function(d) { return d.target.x; })
        .attr("y2", function(d) { return d.target.y; });

    node
        .attr("cx", function(d) { return d.x; })
        .attr("cy", function(d) { return d.y; });
}
    
/* Functions to allow nodes to be dragged */
function dragstarted(d) {
  if (!d3.event.active) simulation.alphaTarget(0.3).restart();
  d.fx = d.x;
  d.fy = d.y;
}

function dragged(d) {
  d.fx = d3.event.x;
  d.fy = d3.event.y;
}

function dragended(d) {
  if (!d3.event.active) simulation.alphaTarget(0);
  d.fx = null;
  d.fy = null;
}
    
// A drop-down menu for selecting a person; uses the "menu" namespace.
dispatch.on("load.menu", function(graph) {
    var select = dropdown.append("select")
                .on("change", function() { dispatch.call("statechange", this, this.value); });

    select.selectAll("option")
        .data(graph.nodes)
        .enter().append("option")
        .attr("value", function(d) { return d.id; })
        .text(function(d) { return d.id; });

    dispatch.on("statechange.menu", function(nodeID) {
        select.property("value", nodeID);
    });
});
    
// Create and update network diagram
dispatch.on("load.graph", function(graph) {

    dispatch.on("statechange.graph", function(nodeID) {
        if (nodeID === null)    {
            buildNetwork(graph);
            return;
        }
        
        if (focus_node !== null)    focus_node = null;
        for (var i in graph.nodes) {
            if (graph.nodes[i].id === nodeID)  {
                set_focus(graph.nodes[i]);
                return;
            }
        }
    });
});
/* When the user clicks on the button,
toggle between hiding and showing the dropdown content */
//function selectFilter() {
//    document.getElementById("filterDropdown").classList.toggle("show");
//}
//
//function filterFunction() {
//    var input, filter, ul, li, a, i;
//    input = document.getElementById("myInput");
//    filter = input.value.toUpperCase();
//    div = document.getElementById("filterDropdown");
//    a = div.getElementsByTagName("a");
//    for (i = 0; i < a.length; i++) {
//        if (a[i].innerHTML.toUpperCase().indexOf(filter) > -1) {
//            a[i].style.display = "";
//        } else {
//            a[i].style.display = "none";
//        }
//    }
//}    

</script>